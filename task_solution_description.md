# Предварительный анализ задачи
Формулировка самой проблемы (привожу ее здесь для удобства): присылается согласие, заполненное пользователем.
Шаблон согласия известен заранее. Есть база предварительно заполненных согласий того-же шаблона (можно работать и без нее, просто это будет менее эффективно).
По факту есть два случая:

1. Согласие некорректно:
    1. Согласие уже встречалось в базе - это можно проверить, сверив хеш согласия с базой. Самый легкий кейс.
    2. Согласие было просто пустое, но по какой-то причине не прошло проверку по хешу. В 99 процентах случаев это просто пустой пдф файл. Отбрасывается легко.
    3. Согласие было заполнено, но частично, почти не заполнено. Самый сложный кейс. Если оно было частично заполнено, его нельзя будет легко отбросить. Погрешность слишком высока. Именно из-за подобных согласий возникает больше всего проблем.
    4. Согласие было заполнено некорректно (сложный случай). Например не та фамилия, или не то поле заполнено и тд. Такое обнаружить невозможно, и бессмысленно пытаться это автоматизировать.
    5. Заполнено согласие правильно, но пользователь сфоткал его невероятно криво, так что ничего не видно например.
    6. Прислано вообще левое изображение, которое никак не относится к согласию.
2. Согласие корректно (все остальные случаи)

Задача - облегчить работу проверяющему, отправлять ему на проверку только сомнительные кейсы, а все остальные автоматически отфильтровывать.
Мы взяли за основу 30 процентов - именно такое число согласий предполагается отправлять оператору от общего числа. Можно больше, можно меньше, это можно будет легко регулировать.
Соответственно, есть пять типов согласий (три основных - 1,2,3, и два дополнительных - 4, 5):

1. Скорее всего некорректные
    1. Левые изображения
    2. Полностью пустые, или практически полностью пустые согласия
    3. Сфотографированные непонятным образом (криво)
    4. Со слетевшей разметкой (пользователь скопировал весь текст из pdf в word, впечатал туда данные и распечатал это чудо)
2. На проверку оператору
    1. Согласия, которые вроде бы заполнены, но частично (не на сто процентов и не на 70). Тут нельзя сказать наверняка, это реально некорректное согласие, или ошибка программы.
    2. Согласия, в принципе не распознанные системой (если система не смогла привести их к нормальному виду - развернуть. об этом будет дальше более подробно).
3. Скорее всего корректные
    1. Полностью или практически полностью заполненные согласия
    2. Некорректно заполненные согласия (тот самый сложный случай. формально они заполнены полностью, но например там просто что-то неразборчивое, или данные не те, вместо паспортных данных - свидетельство о рождении. ну например). Они будут неизбежно попадать в эту категорию, и с этим мало что можно будет сделать.
4. Сто процентов некорректные - те, что уже были в базе - проверяется по хешу.
5. Те, на которых работа программы была прервана с ошибкой - отправляются также на проверку модератору со специальной пометкой.

# Само решение

Мы провели анализ и пришли к выводу, что самое эффективное решение такое:
1. Попытаться развернуть согласие, привести его к стандартному виду (чтобы его можно было как бы "приложить" к исходной пустой форме). Это действие довольно подробно описывается в различных гайдах, хоть и не является тривиальным, происходит относительно быстро, и не требует данных для обучения).
2. Сравнить каждое поле на полученном развернутом согласии с пустотой и оценить, а сколько там вообще чего-то. Если поле выглядит заполненным, считаем, что оно заполнено.
3. Получаем два значения:
    1. Мера того, на сколько изображение было хорошо развернутым (от 0 до 1). В коде - ```similarity_score```. 
    Все что больше 0.25 - круто, согласие развернуто практически идеально. 0.15 и больше - терпимо, но сто процентов есть погрешность. Все что меньше - система не смогла распознать и развернуть.
    2. Мера того, сколько полей заполнено. В коде -  ```percent_filled```. Для хорошо развернутого изображения действует идеально и соответствует реальности. Для плохо развернутого - может служить лишь относительным индикатором. Если оно совсем близко к нулю - скорее всего форма не заполнена (или просто была коряво развернута).

[Пример разворота согласия](https://drive.google.com/file/d/187Px7BoL1RfYbMym-mltmb_85TO10KSR/view?usp=sharing).

Предварительно делаем следующее: Прогоняем нашу программу на всех данных уже размеченных и подбираем три такие интервала для ```similarity_score``` и ```percent_filled```, что:
1. Процент согласий, попавших во второй промежуточный интервал (те которые отправляются оператору) был не больше 30 процентов (например).
2. А процент ложно положительных в третьем интервале (которые скорее всего корректные), был не больше некого значения, выбранного самостоятельно (мы взяли 85 процентов).
   Важно отметить, что для каждого типа согласий такое значение оказывается свое - некоторые типы развернуть (а именно на этом этапе больше всего проблем) довольно легко, а некоторые сильно труднее. Для каких-то согласий возможно 95 процентов, а для некоторых 80 - потолок.
3. Собственно тут и начинает работать перебор, алгоритмически выбирая такие значения, которые выдадут наименьшее количество ложно положительных для первой категории (которые скорее всего не корректные).

А далее собственно уже в реальном времени оцениваем:
1. ```max_possible_correctness_of_alignment_left```, ```max_number_of_filled_fields_left``` - если ```similarity_score``` и ```percent_filled``` соответственно меньше этих значений, то тип первый (скорее всего некорректные)
2. ```max_possible_correctness_of_alignment_right```, ```max_number_of_filled_fields_right``` - если ```similarity_score``` и ```percent_filled``` соответственно больше этих значений, то тип третий (скорее всего корректные)
3. Иначе тип второй - отправляются на проверку оператору.

Что делать если нет размеченных данных? Прежде всего, можно подобрать значения выше эмпирически, основываясь на данных с других согласий. 
Этот способ будет работать, просто не так эффективно.
Или подождать, пока не наберется хотя бы штук 100 размеченных согласий, и запустить перебор.

Самое главное в программе происходит в файле ```alignment.py```.
Три важные функции:
1. ```create_orb_features``` - создание ключевых точек. [хорошая статья про это](https://medium.com/data-breach/introduction-to-orb-oriented-fast-and-rotated-brief-4220e8ec40cf). 
   Если коротко - значения, которые могут как-то охарактеризовать изображение. Тут и пригождается один из параметров - ```max_number_of_features_to_create```. Если коротко - чем больше это значение, тем (в разумных пределах - до 20000) лучше точность, но больше время работы.
2. ```create_orb_features``` - если коротко - поиск сочетаний точек, которые можно использовать для того, чтобы сопоставить два изображения (присланная форма и пустой образец). [хорошая статья про это](https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_feature2d/py_matcher/py_matcher.html).
   И тут пригождается другой параметр - ```percent_of_features_to_keep``` - если коротко - ограничивает в процентах, сколько этих самых вариантов значений мы возьмем с собой дальше.
3. ```find_homography``` - собственно сопоставление двух изображений, "разворот по ключевым точкам". На выходе готовое развернутое изображение.

А также в файле ```recognition.py```.
Две важные функции:
1. ```measure_similarity``` - измеряет, на сколько хорошо было развернуто изображение. Алгоритм оценки был подобран экспериментально. Было проверено много вариантов, конкретно это сочетание дает довольно точную оценку качества разворота. 
   Собственно, здесь мы и получаем значение ```similarity_score```.
2. ```check_right_filling``` - простое прохождение по координатам полей (заранее заданных) и проверка на то, является ли выбранное поле заполненным.
   Осуществляется это посредством простой функции ```mse``` (средняя квадратичная ошибка). 
   Кусочек присланной формы, который закрывает часть соответствующего поля, сравнивается с таким же кусочком на пустой форме (зачастую это просто пустое пространство с полосой внизу, выше которой должны быть данные пользователя - она оставлена, так как зачастую разворот не идеален и эта полоса часто попадает в границы поля. Так что лучше просто сравнивать вместе с ней. Иначе система может посчитать, что поле заполнено, хотя на самом деле в него просто попала эта полоса).
   Безусловно, ```mse``` не самая эффективная, однако очень быстрая, а в условиях, когда есть 10-20 полей это становится критичным.
   Соответственно, мы получаем значение ```percent_filled``` - процент заполненных полей.
   Тут используется последний важный параметр - ```threshold_of_filling_for_fields``` - если значение на выходе ```mse``` выше него, можно сказать, что поле заполнено. Экспериментально подобрано значение 5000 для этого параметра.

```max_number_of_features_to_create``` и ```percent_of_features_to_keep``` - одни из основных параметров для тюнинга. Как их можно найти? 
Взять уже размеченные данные (корректные), и попробовать найти такое сочетание этих двух параметров, которое дает наибольшее средне значение ```measure_similarity```. 
Также можно взять несколько пар таких значений - это замедляет вычисления, но позволяет закрыть больше разных случаев (с разворотом одной формы справилась одна пара значений, с другой формой уже другая).
Это экспериментально нами было проверено - работает увеличение количества пар (до двух - трех). Однако в реальную работу включать мы это не стали, так как тогда время работы программы превышает две секунды в таком случае.

В файле ```image_class``` - работа с присланным согласием. Управление функциями, описанными выше. В ```template_class``` - работа с шаблоном.
В ```manager_class``` - все самое главное - это интерфейс для работы со всей утилитой. 
Загружает параметры, использует комбинации функций из ```image_class``` и ```template_class``` для работы.

Почему именно такой алгоритм, а не любой другой?
1. Почти не требует данных для работы (хотя они будут очень кстати).
2. Для добавления новой формы достаточно совсем немного усилий (запустить скрипт и перебрать значения).
3. Сам алгоритм работает достаточно быстро даже на очень слабом железе и не требует gpu для работы.
4. Так как очень много некачественных данных приходит (форму не так сфоткали, плохое качество и тд), использовать более мощные и сложные алгоритмы будет просто не эффективно. Прирост в точности не будет стоить прироста в сложности разработки и требуемых для работы мощностей.

Самый критичный этап - разворот изображения.


# Использование нового типа согласия

Как загрузить в систему новое согласие для использования.
1. Разметить и сохранить в отдельный файл формата ```template_data/sogl1_fields.json```. Отдельная детальная инструкция по этому пункту будет составлена чуть позже.
2. Подобрать значения ```max_number_of_features_to_create``` и ```percent_of_features_to_keep``` в соответствии с алгоритмом выше.
3. Вычислить ```similarity_score``` и ```percent_filled``` для каждого изображения в выборке
4. Подобрать ```max_possible_correctness_of_alignment_left```, ```max_number_of_filled_fields_left```, ```max_possible_correctness_of_alignment_right```, ```max_number_of_filled_fields_right``` - также в соответствии с уже предложенным алгоритмом выше.
5. Создать конфигурационный файл и занести туда все полученные значения.

Алгоритмы для пункта 2 и 4 уже есть, но еще идет работа над тем, чтобы сделать их адекватно воспринимаемыми и понятными. В скором времени будет готово.